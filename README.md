# Тестовое задание Junior Data Analyst
* [Задание №1](#Задание_№1)
* [Решение Задания №1](#Решение_Задания_№1)
* [Задание №2](#Задание_№2)
* [Решение Задания №2](#Решение_Задания_№2)
* [Инструкция по запуску скрипта](#Инструкция_по_запуску_скрипта)

<a name="Задание_№1"></a>
### Задание №1 — Работа с данными
Входные данные для тестового задания можно найти [здесь](https://docs.google.com/spreadsheets/d/165sp-lWd1L4qWxggw25DJo_njOCvzdUjAd414NSE8co/edit?usp=sharing) (или [здесь](https://docs.google.com/spreadsheets/d/1SWZCf9MSjP1wNuphLEOH9bA23qbUIyt9/edit?usp=sharing&ouid=100308789753749109392&rtpof=true&sd=true), резервная ссылка).
Ваша задача - подготовить и обработать исходные данных так, чтобы их можно было использовать во второй части задания.

**Требования к выходным данным:**<
1.     В выходной таблице должны остаться только следующие колонки:
* _area, cluster, cluster_name, keyword, x, y, count, color_, где:
*  _area_ - область,
*  _cluster_ - номер кластера,
*  _cluster_name_ - название кластера,
*  _keyword_ - словосочетание,
*  _count_ - показатель,
*  _x_ и _y_ - координаты для диаграммы рассеяния,
*  _color_ - цвет точки на карте для данного словосочетания
2.      Колонку color нужно добавить самостоятельн
3.      Цвет задается каждому словосочетанию согласно следующими правилам:
* внутри одной области цвета словосочетаний в одном кластере должны быть одинаковые, в разных - отличаться (например, у "Кластер 1" все слова будут окрашены в красный, у "Кластер 2" - в зеленый и т.д.)
* цвета кластеров в разных областях могут повторяться
* цвета кластеров в разных областях с разным номером не имеют никакой связи (у одной области _[area]_ слова из "Кластер 1" могут быть красного цвета, в другой области у слов из "Кластер 1" может быть другой цвет)
4.     Не должно быть дубликатов слов в одной и той же области (area), но словосочетание может повторяться из area в area
5.     Колонки должны называться именно так, как указано в п.1
6.     Сортировка должна происходить по колонкам area, cluster, cluster_name, count (по count значения сортируются в убывающем порядке, в остальных - по возрастающему).
7.     Количество переданных в исходных ключевых слов должно совпадать с количество слов в выходных данных (за исключением дублированных строк или строк с пустыми\неформатными значениями по ключевым показателям [перечислены в п. 1], если такие имеются).
8.     Никакие другие особенности оформления не должны учитываться при обработке данных (заливка и пр.)
9.     Выходные данные должны быть аккуратно оформлены (заголовки закреплены, включен фильтр)
Формат представления выходных данных: google spreadsheet-таблица.
Выполнение данной работы желательно с помощью одной из библиотек:
* data.table ( R )
* pandas  (Python)

<a name="Решение_Задания_№1"></a>
### Решение задания №1
1. Делаем себе [копию](https://docs.google.com/spreadsheets/d/18Pzfrg0VEoHBcZqB19Nl7SrcSZ4ivOnQgAQOfYCwe30/edit#gid=1439079331) Google Sheets, выдаем права на редактирование документа.
2. Читаем данные из нашей копии Google Sheets, вызвав функцию _google_API_get()_
```shell
    values = service.spreadsheets().values().get(
        spreadsheetId=spreadsheet_id,
        range='tz_data',
        majorDimension='ROWS').execute()
```
3. Для удобного чтения полученных данных и дальнейшей обработки формируем файл "csv_data.csv", через функцию _csv_data()_
4. Вызвав функцию _analyst_data()_ приступаем к анализу и обработке данных:
* добавляем столбец color:
```shell
data.insert(8, 'color', None)  
```
* Преобразовываем аргументы(string) (значения в колонке _'count'_) в числовую форму, для дальнейшей сортировки значений по _'count'_:
```shell
data['count'] = pd.to_numeric(arg=data['count'], errors='coerce', downcast='integer') 
```
* Объявляем словарь "_d1_", Для предварительной записи "color", "keyword", что бы избежать повторов:
```shell
d1 = dict() 
``` 
* Через цикл _for_ добавляем в колонку color цвет в соответствии с условием, удаляем повтор "keyword" в одной области area:
```shell
for row in data.itertuples():  # получаем кортеж из строки по всем столбцам 
 # если область "area" (row[1]) нет в словаре, то добавляем его и его первый кластер (row[2]) + цвет (col)
         if row[1] not in d1: 
            col = random.choice(color) # цвет выбираем из ранее созданного списка "color"
             # Добавляем в словарь: row[1] - область, row[2] - название кластера, row[4] - словосочетание
            d1[row[1]] = {row[2]: col, 'keyword':[row[4]]}]
            data.loc[row[0], 'color'] = col  # добавляем в колонку таблицы цвет
         
         # если "area" есть в словаре и "keyword" в этой области тоже есть, то удаляем новый повтор
         elif row[1] in d1 and row[4] in d1[row[1]]['keyword']:
            data = data.drop(index=row[0])
         
         # если в словаре есть "area" и есть кластер, то просто назначаем цвет ранее добавленного кластера
         elif row[1] in d1 and row[2] in d1[row[1]]:  
            data.loc[row[0], 'color'] = d1[row[1]][row[2]]  # добавляем в колонку таблицы цвет 
            d1[row[1]]['keyword'].append(row[4])  # добавляем в словарь словосочетание для выбранной области
        
         # если в словаре есть "area", но нет кластера, прибавляем кластер + новый цвет
         elif row[1] in d1 and row[2] not in d1[row[1]]:  
            col = random.choice(color)
            while col in d1[row[1]].values():  # смотрим, что бы не было повторов цветов у "area" 
                col = random.choice(color)
            d1[row[1]][row[2]] = col  
            d1[row[1]]['keyword'].append(row[4])
            data.loc[row[0], 'color'] = col  # добавляем в колонку таблицы цвет
```


<a name="Задание_№2"></a>
### Задание №2 — Построение графиков
На основании обработанных данных постройте по одной диаграмме рассеяния для каждой области (_area_) (пример внешнего вида см. в приложенном [svg-файле](https://drive.google.com/file/d/1uxxkyPipGoR4ZLluxV7S1acLZw3Y4VuS/view?usp=sharing)).

**Требования к визуализации:**
* Наличие Footer-подписи на изображении
* Наличие легенды цветов и кластеров
* Перенос слишком длинных словосочетаний (например, слова длиннее 15 символов, можно разбить на "solar\n cell")
* Минимизация наложения (слепливания) подписей к друг на друга (постарайтесь сделать так, чтобы наложение было минимальным)
* Обводка точек.

Формат представления выходных данных: png-файлы размером не менее 1500х1500 пикселей с визуализациями  для каждой области (area).

Выполнение данной работы желательно с помощью одной из библиотек:
* ggplot2 ( R )
* Matploptlib  (Python)
* plotly (Python) и т.п.


<a name="Решение_Задания_№2"></a>
### Решение задания №2


<a name="Инструкция_по_запуску_скрипта">Инструкция по запуску скрипта</a>
1. перейти в папку \Pandas_Matplotlib\script_run
2. в терминале находясь в папке "script_run" ввести следующую команду:
```shell
python data_plot.py run
```
После запуска скрипта в терминале будут приходить сообщения о ходе выполнения программы:
```shell
...
[19.09.2022 13:34:40] Чтение исходных данных Google Sheets - успешно завершено
[19.09.2022 13:34:40] Cоздан файл исходных данных Google Sheets: "csv_data.csv" 
[19.09.2022 13:34:40] Анализ данных, сортировка данных, добавление "color" - успешно завершено
[19.09.2022 13:34:40] Начат процесс переноса данных в новый Google Sheets
[19.09.2022 13:34:53] Перенесено: 50 - строк. Делаем паузу 60сек. (не перегружаем API)
..
[19.09.2022 13:39:40] Перенос данных в Google Sheets(ссылка ниже) - успешно завершено
[19.09.2022 13:39:40] https://docs.google.com/spreadsheets/d/19WU-rV31bktdBMZR1RM-ODJuuHamwcKaplPAJ-LEItY/edit#gid=0
[19.09.2022 13:39:40] Приступаем к созданию графиков
[19.09.2022 13:39:41] График для области ar\vr - успешно создан
...

```